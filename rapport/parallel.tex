\section{Implémentation des différentes versions} % (fold)
\label{sec:diff_rents_versions}
Dans cette partie, nous allons exposer les différentes versions parallèles du jeu de la vie que nous avons développées. Dans un premier temps, nous allons voir les différentes versions utilisant une mémoire partagée (section \ref{partagee}), puis les version MPI (section \ref{mpi}), utilisant d'abord des communications synchrones, puis des communications asynchrones, et enfin persistantes.

\subsection{Mémoire partagée}
\label{partagee}

\subsubsection{OpenMP}
\label{openmp}
\paragraph{Principe}
Dans le cas d'OpenMP, on va essayer de paralléliser les boucles de calcul du nombre de voisins et d'actualisation des cellules en fonction du nombre de voisins (exemples \ref{boucle_voisins} et \ref{boucle_actualisation}). Pour cela, on spécifie simplement que l'on veut effectuer les boucles $for$ en parallèle avec l'instruction \ref{omp_parallel}, insérée juste avant les boucles. Dans le cas de l'exemple \ref{boucle_actualisation}, on veut calculer le nombre de cellules vivantes aussi. Pour ce faire, on effectue une réduction, employant l'opérateur addition sur la variable $num\_alive$. 

\begin{figure}[h!]
\begin{lstlisting}
for (j = 1; j <= BS; j++) do
	for (i = 1; i <= BS; i++) do
		ngb( i, j ) =
		cell( i-1, j-1 ) + cell( i, j-1 ) + cell( i+1, j-1 ) +
		cell( i-1, j   ) +                  cell( i+1, j   ) +
		cell( i-1, j+1 ) + cell( i, j+1 ) + cell( i+1, j+1 );
	end do
end do
\end{lstlisting}
\caption{Boucle calculant le nombre de voisins}
\label{boucle_voisins}
\end{figure}


\begin{figure}[h!]
\begin{lstlisting}
for (j = 1; j <= BS; j++) do
	for (i = 1; i <= BS; i++) do
		if ( (ngb( i, j ) < 2) || (ngb( i, j ) > 3) ) 
			cell(i, j) = 0;
		else 
			if ((ngb( i, j )) == 3)
			cell(i, j) = 1;
		fi
		if (cell(i, j) == 1) 
			num_alive ++;
		fi
	end do
end do
\end{lstlisting}
\caption{Boucle calculant l'état suivant des cellules et comptant le nombre de cellules vivantes}
\label{boucle_actualisation}
\end{figure}

\begin{figure}[h!]
	\begin{lstlisting}
		#pragma omp parallel for private(i,j)
	\end{lstlisting}
	\caption{Instruction OpenMP}
	\label{omp_parallel}
\end{figure}

\paragraph{Pavage}
Nous avons implémenté une version OpenMP utilisant la notion de \emph{pavage}. Il s'agit de découper les boucles en $N$ plus petites boucles. Le but est de faire correspondre la taille des petites boucles avec la taille du cache, afin de bénéficier de ses performances. 

\subsubsection{pthread}
\label{pthread}


\subsection{Mémoire distribuée: MPI} % (fold)
\label{mpi}


\subsubsection{Communications synchrones}
\subsubsection{Communications asynchrones}
\subsubsection{Communications persistantes}
